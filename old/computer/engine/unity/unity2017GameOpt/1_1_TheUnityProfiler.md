
# The Unity Profiler

Unity Profiler是Unity编辑器的内置工具，在运行期，通过生成大量硬件子系统的使用情况、图表，提供适宜的方法缩小范围，找到性能瓶颈。不同硬件子系统能够收集的信息在下边列出。

- CPU消耗（每个主要的子系统）
- 基本和详细的渲染信息和GPU信息
- 运行期内存分配和整体的消耗情况
- 声音数据使用情况
- 物理系统（2D和3D）使用情况
- 网络消息和系统使用情况
- 视频播放情况
- 基本和详细的用户界面性能情况（Unity 2017新加入的）
- 全局光照（Global Illumination）统计（Unity 2017新加入的）

还有两款通用的性能分析工具：**Instrumentation** 和 **Benchmarking**（尽管，诚然，它们经常换着用)

Instrumentation 通常意思是近距离观察程序内部工作，观察每一个函数调用的表现，内存在哪里被申请，通常可以准确的了解发生了什么，并希望找到问题的原因。然而，这通常不是开始发现性能问题的有效方法，因为对任何程序的性能检查本身也有消耗。

当一个Unity程序使用开发模式编译时（在Build Settings菜单中，由Development Build开启或关闭），程序将启用额外的编译指令，使其在运行期生成特殊的事件，通过Profiler记录并存储。当然，这会在运行期带来额外的CPU和内存开销，因为应用程序额外承担了这些。应用程序通过Unity编辑器直接性能测试可能更糟，为确保编辑器更新它的界面，渲染额外的窗口（比如场景窗口），处理后台任务，更多CPU和内存会被消耗。这些性能测试的开销并不总是可以被忽略的。在一些超大的项目中，启用性能检测有时可能引起行为不一致的表现。有些例子中，由于事件时间的变化和潜在的多线程异步竞争，会导致这种严重的不一致，足以引起完全不可预期的结果。在运行期这是一个必要的开销用以分析我们的代码行为，我们应该一直意识到性能检查的存在。

在开始检查我们程序中的每一行代码之前，先使用平台级的性能检测是更明智的选择。我们应该将游戏运行在目标硬件上，运行测试我们的游戏场景，收集一些原始数据。这个测试可以是非常简单的玩一小会儿，剪辑场景的回放，场景的部分测试等等。这项活动的想法是得到玩家游玩的普遍感受，并继续观察，直到性能明显变糟。这些问题也许足以证明接下来的性能分析是必要的。


